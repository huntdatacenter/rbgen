import platform
 
srcdir="."
APPNAME = "bgen"
VERSION = "1.0"

def options( opt ):
	opt.load( 'compiler_cxx' )
	opt.load( 'compiler_c' )
	opt.add_option( '--mode', action = 'store', default = 'release', dest = 'mode' )
	
def configure( cfg ):
	cfg.load( 'compiler_c')
	cfg.load( 'compiler_cxx')
	cfg.env.CXXFLAGS = [ '-Wall', '-pedantic', '-Wno-unused-local-typedefs', '-Wno-c++11-long-long', '-Wno-deprecated-declarations', '-Wno-long-long', '-fPIC' ]
	cfg.env.CFLAGS = [ '-Wall', '-pedantic', '-Wno-unused-local-typedefs', '-Wno-c++11-long-long', 'Wno-deprecated-declarations', '-Wno-long-long', '-fPIC' ]
	if cfg.options.mode == 'release':
		cfg.env.CXXFLAGS += [ '-O3' ]
		cfg.env.CFLAGS = [ '-O3' ]
	elif cfg.options.mode == 'debug':
		cfg.env.CXXFLAGS += [ '-g' ]
		cfg.env.CFLAGS = [ '-g' ]
	else:
		raise Exception( "Unknown value for --mode, please specify --mode=debug or --mode=release" )

	cfg.check_cxx( lib='z', uselib_store='zlib', msg = 'zlib' )
	if platform.system() != "Darwin":
		cfg.check_cxx( lib='rt', uselib_store='rt', msg = 'rt' )
		cfg.check_cxx( lib='pthread', uselib_store='pthread', msg = 'pthread' )
		cfg.check_cxx( lib='dl', uselib_store='dl', msg = 'dl' )

def build( bld ):
	print "Creating %s build..." % bld.options.mode
	bld(
		rule = """printf '#ifndef BGEN_REVISION_HPP\n#define BGEN_REVISION_HPP\nnamespace globals {\n\tchar const* bgen_version = \"%%s\" ;\n\tchar const* const bgen_revision = \"%%s\" ;\n}\n#endif\n' `echo """ + VERSION + "` `hg parents --template={node}` > ${TGT}""",
		always = True,
		target = "bgen_revision_autogenerated.hpp",
		name = "bgen_revision_autogenerated",
		uselib = "",
		#on_results = True
		on_results = False
	)

	bld.stlib(
		source = bld.path.ant_glob( 'src/*.cpp' ),
		target = 'bgen',
		includes = 'genfile/include',
		use = 'zlib zstd sqlite3 db',
		export_includes = 'genfile/include'
	)
	bld.recurse( [ '3rd_party', 'appcontext', 'db', 'apps', 'example', 'test', 'R' ] )

class ReleaseBuilder:
	def __init__( self, APPNAME, VERSION ):
		self.APPNAME = APPNAME
		self.VERSION = VERSION
		self.apps = [ 'bgenix', 'cat-bgen', 'edit-bgen' ]

	def build( self ):
		import os, tempfile, shutil, subprocess
		tempdir = tempfile.mkdtemp()
		import platform
		if platform.system() == 'Darwin':
			release_stub = '%s_v%s-osx' % ( self.APPNAME, self.VERSION )
		elif platform.system() == 'Linux':
			distro = platform.linux_distribution()
			release_stub = '%s_v%s-%s%s-%s' % ( self.APPNAME, self.VERSION, distro[0], distro[1], platform.machine() )
		release_dir = os.path.join( tempdir, release_stub )
		os.mkdir( release_dir )
		shutil.copyfile( "LICENSE_1_0.txt", os.path.join( release_dir, "LICENSE_1_0.txt" ) )
		for app in self.apps:
			source = os.path.join( 'build', 'apps', app )
			target = os.path.join( release_dir, app )
			shutil.copyfile( source, target )
			shutil.copymode( source, target )
		shutil.copytree( 'example', os.path.join( release_dir, 'example' ), ignore = shutil.ignore_patterns( '*.cpp', 'wscript' ))
		target_tarball = '%s/%s.tgz' % ( tempdir, release_stub )
		process = subprocess.Popen( [ 'tar', '-czf', target_tarball, release_stub ], cwd = tempdir )
		process.wait()
		print 'Created %s release tarball in "%s"' % ( self.APPNAME, target_tarball )
		print "Contents are:"
		print subprocess.Popen( [ 'tar', '-tzf', target_tarball ], stdout = subprocess.PIPE ).communicate()[0]
		return { "release_tarball": target_tarball }

def release( bld ):
	release = ReleaseBuilder( APPNAME, VERSION )
	result = release.build()
	print "Created %s release tarball in \"%s\"" % ( APPNAME, result['release_tarball'] )
